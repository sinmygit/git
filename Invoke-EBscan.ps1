function Invoke-EBScan
{
param ($currip)
$Source = @"
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Text;

namespace PingCastle.Scanners
{
	public class m17sc
	{
		static public bool Scan(string computer)
		{
			TcpClient client = new TcpClient();
			client.Connect(computer, 445);
			try
			{
				NetworkStream stream = client.GetStream();
				byte[] negotiatemessage = GetNegotiateMessage();
				stream.Write(negotiatemessage, 0, negotiatemessage.Length);
				stream.Flush();
				byte[] response = ReadSmbResponse(stream);
				if (!(response[8] == 0x72 && response[9] == 00))
				{
					throw new InvalidOperationException("invalid negotiate response");
				}
				byte[] sessionSetup = GetR(response);
				stream.Write(sessionSetup, 0, sessionSetup.Length);
				stream.Flush();
				response = ReadSmbResponse(stream);
				if (!(response[8] == 0x73 && response[9] == 00))
				{
					throw new InvalidOperationException("invalid sessionSetup response");
				}
				byte[] treeconnect = GetTreeConnectAndXRequest(response, computer);
				stream.Write(treeconnect, 0, treeconnect.Length);
				stream.Flush();
				response = ReadSmbResponse(stream);
				if (!(response[8] == 0x75 && response[9] == 00))
				{
					throw new InvalidOperationException("invalid TreeConnect response");
				}
				byte[] peeknamedpipe = GetPeekNamedPipe(response);
				stream.Write(peeknamedpipe, 0, peeknamedpipe.Length);
				stream.Flush();
				response = ReadSmbResponse(stream);
				if (response[8] == 0x25 && response[9] == 0x05 && response[10] ==0x02 && response[11] ==0x00 && response[12] ==0xc0 )
				{
					return true;
				}
			}
			catch (Exception)
			{
				throw;
			}
			return false;
		}

		private static byte[] ReadSmbResponse(NetworkStream stream)
		{
			byte[] temp = new byte[4];
			stream.Read(temp, 0, 4);
			int size = temp[3] + temp[2] * 0x100 + temp[3] * 0x10000;
			byte[] output = new byte[size + 4];
			stream.Read(output, 4, size);
			Array.Copy(temp, output, 4);
			return output;
		}

		static byte[] GetNegotiateMessage()
		{
			byte[] output = new byte[] {
				0x00,0x00,0x00,0x00, 
				0xff,0x53,0x4d,0x42, 
				0x72, 
				0x00, 
				0x00,
				0x00,0x00, 
				0x18, 
				0x01,0x28, 
				0x00,0x00, 
				0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
				0x00,0x00, 
				0x00,0x00, 
				0x44,0x6d, 
				0x00,0x00, 
				0x42,0xc1, 
				0x00, 
				0x31,0x00,
				0x02,0x4c,0x41,0x4e,0x4d,0x41,0x4e,0x31,0x2e,0x30,0x00, 
				0x02,0x4c,0x4d,0x31,0x2e,0x32,0x58,0x30,0x30,0x32,0x00, 
				0x02,0x4e,0x54,0x20,0x4c,0x41,0x4e,0x4d,0x41,0x4e,0x20,0x31,0x2e,0x30,0x00, 
				0x02,0x4e,0x54,0x20,0x4c,0x4d,0x20,0x30,0x2e,0x31,0x32,0x00, 
			};
			return EncodeNetBiosLength(output);
		}

		static byte[] GetR(byte[] data)
		{
			byte[] output = new byte[] {
				0x00,0x00,0x00,0x00, 
				0xff,0x53,0x4d,0x42, 
				0x73, 
				0x00, 
				0x00, 
				0x00,0x00, 
				0x18, 
				0x01,0x28, 
				0x00,0x00, 
				0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
				0x00,0x00, 
				data[28],data[29],data[30],data[31],data[32],data[33],
				0x42,0xc1, 
				0x0d, 
				0xff, 
				0x00, 
				0x00,0x00, 
				0xdf,0xff, 
				0x02,0x00,
				0x01,0x00, 
				0x00,0x00,0x00,0x00, 
				0x00,0x00, 
				0x00,0x00, 
				0x00,0x00,0x00,0x00, 
				0x40,0x00,0x00,0x00, 
				0x26,0x00, 
				0x00,
				0x2e,0x00, 
				0x57,0x69,0x6e,0x64,0x6f,0x77,0x73,0x20,0x32,0x30,0x30,0x30,0x20,0x32,0x31,0x39,0x35,0x00, 
				0x57,0x69,0x6e,0x64,0x6f,0x77,0x73,0x20,0x32,0x30,0x30,0x30,0x20,0x35,0x2e,0x30,0x00 
			};
			return EncodeNetBiosLength(output);
		}

		private static byte[] EncodeNetBiosLength(byte[] input)
		{
			byte[] len = BitConverter.GetBytes(input.Length-4);
			input[3] = len[0];
			input[2] = len[1];
			input[1] = len[2];
			return input;
		}

		static byte[] GetTreeConnectAndXRequest(byte[] data, string computer)
		{
			MemoryStream ms = new MemoryStream();
			BinaryReader reader = new BinaryReader(ms);
			byte[] part1 = new byte[] {
				0x00,0x00,0x00,0x00, 
				0xff,0x53,0x4d,0x42, 
				0x75, 
				0x00, 
				0x00, 
				0x00,0x00, 
				0x18, 
				0x01,0x28, 
				0x00,0x00, 
				0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
				0x00,0x00, 
				data[28],data[29],data[30],data[31],data[32],data[33],
				0x42,0xc1, 
				0x04, 
				0xff, 
				0x00, 
				0x00,0x00, 
				0x00,0x00, 
				0x01,0x00, 
				0x19,0x00, 
				0x00, 
				0x5c,0x5c};
			byte[] part2 = new byte[] {
				0x5c,0x49,0x50,0x43,0x24,0x00, 
				0x3f,0x3f,0x3f,0x3f,0x3f,0x00
			};
			ms.Write(part1, 0, part1.Length);
			byte[] encodedcomputer = new ASCIIEncoding().GetBytes(computer);
			ms.Write(encodedcomputer, 0, encodedcomputer.Length);
			ms.Write(part2, 0, part2.Length);
			ms.Seek(0, SeekOrigin.Begin);
			byte[] output = reader.ReadBytes((int) reader.BaseStream.Length);
			return EncodeNetBiosLength(output);
		}

		static byte[] GetPeekNamedPipe(byte[] data)
		{
			byte[] output = new byte[] {
				0x00,0x00,0x00,0x00, 
				0xff,0x53,0x4d,0x42,
				0x25, 
				0x00,
				0x00, 
				0x00,0x00, 
				0x18, 
				0x01,0x28, 
				0x00,0x00,
				0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
				0x00,0x00, 
				data[28],data[29],data[30],data[31],data[32],data[33],
				0x42,0xc1,
				0x10, 
				0x00,0x00, 
				0x00,0x00, 
				0xff,0xff, 
				0xff,0xff, 
				0x00, 
				0x00, 
				0x00,0x00,
				0x00,0x00,0x00,0x00, 
				0x00,0x00, 
				0x00,0x00, 
				0x4a,0x00, 
				0x00,0x00,
				0x4a,0x00, 
				0x02,
				0x00, 
				0x23,0x00, 
				0x00,0x00, 
				0x07,0x00, 
				0x5c,0x50,0x49,0x50,0x45,0x5c,0x00 
			};
			return EncodeNetBiosLength(output);
		}
	}
}
"@
aDd-TYpe -TypeDefinition $Source
try{
$vul=[PingCastle.Scanners.m17sc]::Scan($currip)
if($vul) {write-host $currip"   vulnerable"}
}catch{}
}
